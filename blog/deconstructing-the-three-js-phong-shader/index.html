<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>DJH - Deconstructing the Three.js Phong Shader</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/blog/feed.xml" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/style.css">
</head>
<body>
    <div id="container">
        <header id="header">
            <span><a href="/">DJH</a></span>
            <span id="header-nav"><a href="/">About</a>  | <a href="/blog">Blog</a></span>
        </header>

        <div id="main" role="main">
                <div class="post-header">
        <h1>Deconstructing the Three.js Phong Shader</h1>
    </div>
    <div class="post-body">
        <div class="left-col">
            <span class="post-date"><a href="/">October 30, 2014</a></span>
        </div>
        <div class="main-col">
            <p>(This is homework. You&#39;re probably better off learning about shaders from one of my sources.)</p>

<p>In this blog post, we&#39;re going to look at shaders in WebGL, in particular the Phong Shader implementation in three.js, a Javascript 3d graphics library. The code is <a title="Phong shader examples - GitHub" href="https://github.com/dj/phong_shader">here.</a></p>

<h2>Phong Shading</h2>

<p>Phong Shading generally refers to either the <a title="Phong reflection model - Wikipedia" href="http://en.wikipedia.org/wiki/Phong_reflection_model">Phong reflection model</a>, the <a title="Phong shading - Wikipedia" href="http://en.wikipedia.org/wiki/Phong_shading">Phong normal-vector interpolation technique</a> or a combination of both techniques. Essentially, Phong Shading meant to empirically approximate the way that shiny surfaces reflect light. It is made up of 3 components:</p>

<ul>
<li><a title="Diffuse reflection - Wikipedia" href="http://en.wikipedia.org/wiki/Diffuse_reflection">The diffuse reflection</a> exhibited by rough surfaces</li>
<li>The ambient light in the room</li>
<li><a title="Specular reflection - Wikipedia" href="http://en.wikipedia.org/wiki/Specular_reflection">The specular reflection</a> exhibited by shiny surfaces. Phong informally observed that shiny surfaces have small, intense specular highlights that fade away quickly (the &quot;white&quot; highlights on shiny surfaces in computer generated graphics).</li>
</ul>

<p><a title="Phong components - Wikipedia" href="http://en.wikipedia.org/wiki/Phong_shading#mediaviewer/File:Phong_components_version_4.png"><img alt="Phong components" src="/images/2014-10-30-deconstructing-the-three-js-phong-shader/phong-components.png" /></a></p>

<p><a title="Phong components - Wikipedia" href="http://en.wikipedia.org/wiki/Phong_shading#mediaviewer/File:Phong_components_version_4.png">Phong Components</a></p>

<h2>Per Pixel Shading</h2>

<p>Generally, shaders are built around two functions, a vector shader function that operates on every vector in the mesh and a fragment shader that operates on every pixel in the mesh. Phong shading is a per pixel shading technique, meaning that it is mainly implemented by the fragment shader.</p>

<p><a title="Phong for Dummies - gameprogrammer.net" href="http://www.gameprogrammer.net/delphi3dArchive/phongfordummies.htm"><img alt="Shaded sphere from top" src="/images/2014-10-30-deconstructing-the-three-js-phong-shader/phong-reflection.png" /></a></p>

<p>This diagram helps illustrate the inputs to the fragment shader, in particular the surface normal (the vector that is facing outwards and perpendicular to a line tangent to our pixel), the vector to eye (the vector pointing from the pixel to the camera) and the vector to the light source.</p>

<p>The fragment shader takes these inputs and calculates the diffuse term of the phong shader, to be combined with the ambient and specteral terms. The larger the angle between the surface normal and the vector to the light source, the darker the pixel will be. If the angle between the normal and the light source is greater than a right angle, the diffuse term will be 0, the spectual term will be 0, and the pixel&#39;s color will be determined by the ambient term of the equation. If the camera and light source are positioned close to each other, and the angle between them is small or 0, the diffuse term will be larger and will make the pixel&#39;s color brighter.</p>

<h2>Setting Up the Scene with Three.js</h2>

<p>First of all, it&#39;s a little dark in here. After some boilerplate code to set up the scene, we need to do give the scene some ambient light before we can see anything.</p>
<pre class="highlight javascript"><span class="c1">// Ambient light
</span><span class="kd">var</span> <span class="nx">ambientLight</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">AmbientLight</span><span class="p">(</span><span class="mh">0x888888</span><span class="p">);</span>
<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">ambientLight</span><span class="p">)</span>
</pre>
<p>Now that we have some ambient lighting, we should be able to see what we put in our scene. We can make sphere with a simple green color mesh like so.</p>
<pre class="highlight javascript"><span class="c1">// Make the sphere
</span><span class="kd">var</span> <span class="nx">geometry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">SphereGeometry</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="nx">material</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">({</span> <span class="na">color</span><span class="p">:</span> <span class="mh">0x222222</span> <span class="p">});</span>

<span class="nx">sphere</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="nx">geometry</span><span class="p">,</span> <span class="nx">material</span><span class="p">);</span>

<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">sphere</span><span class="p">);</span>
</pre>
<p>Now we have a dimly lit sphere, but every pixel has the same color value.</p>

<p><a title="Unshaded Sphere" href="http://hartman.dj/phong_shader/ex1.html"><img alt="Unshaded sphere demo" src="/images/2014-10-30-deconstructing-the-three-js-phong-shader/sphere-1.png" /></a></p>

<p><a title="Unshaded Sphere" href="http://hartman.dj/phong_shader/ex1.html">Demo</a></p>

<p>I&#39;ve included a Three.js plugin that gives you orbital mouse controls similar to most 3d modelling programs. You can zoom or out, but no matter what angle you look at the sphere, it pretty much looks flat.</p>

<h2>Using Phong Materials in Three.js</h2>

<p>First, we need to add a directional light. In Three.js, directional lights don&#39;t actually have positions, just a direction.</p>
<pre class="highlight javascript"><span class="c1">// Lighting
</span><span class="kd">var</span> <span class="nx">ambientLight</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">AmbientLight</span><span class="p">(</span><span class="mh">0x888888</span><span class="p">),</span>
    <span class="nx">directionalLight</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">DirectionalLight</span><span class="p">(</span> <span class="mh">0xffffff</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>

<span class="c1">// Position the light, pointing at the origin
</span><span class="nx">directionalLight</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">directionalLight</span><span class="p">);</span>
<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">ambientLight</span><span class="p">);</span>
</pre>
<p>To use a Phong shader in Three.js, we create a MeshPhongMaterial and provide it with variables to define the colors of its ambient, diffuse and specular terms.</p>
<pre class="highlight javascript"><span class="c1">// Shade a sphere
</span><span class="kd">var</span> <span class="nx">geometry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">SphereGeometry</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">phongShader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshPhongMaterial</span><span class="p">({</span>
    <span class="na">ambient</span><span class="p">:</span>    <span class="mh">0x222222</span><span class="p">,</span>
    <span class="na">color</span><span class="p">:</span>      <span class="mh">0x222222</span><span class="p">,</span>
    <span class="na">specular</span><span class="p">:</span>   <span class="mh">0xffffff</span><span class="p">,</span>
    <span class="na">shininess</span><span class="p">:</span>  <span class="mi">2</span><span class="p">,</span>
    <span class="na">shading</span><span class="p">:</span>    <span class="nx">THREE</span><span class="p">.</span><span class="nx">SmoothShading</span>
<span class="p">});</span>

<span class="nx">sphere</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="nx">geometry</span><span class="p">,</span> <span class="nx">phongShader</span><span class="p">);</span>
<span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">sphere</span><span class="p">);</span>
</pre>
<p><a title="Shaded Sphere" href="http://hartman.dj/phong_shader/ex2.html"><img alt="Shaded sphere demo" src="/images/2014-10-30-deconstructing-the-three-js-phong-shader/sphere-2.png" /></a></p>

<p><a title="Shaded Sphere" href="http://hartman.dj/phong_shader/ex2.html">Demo</a></p>

<h2>Phong Shader Implementation in Three.js</h2>

<p>Let&#39;s take a look at the three.js source to see how the Phong shader is implemented. The WebGL API allows shaders to be expressed as strings of GLSL functions. This makes the Javascript source which deals with shaders quite ugly and difficult to read. Part of this is because Javascript doesn&#39;t support multi-line strings. To get around this, Three.js stores shaders as arrays of strings, with each string on a new line. Large parts of shader code that don&#39;t need to be changed much are stored as .glsl files for reuse between shaders.</p>

<p>Before we look at the code though, a word about shaders. In most shading languages, shaders declare three types of variables:</p>

<ul>
<li><strong>Uniforms</strong> are read-only variables that represent global constants for the shaders. This is something like the ambient light.</li>
<li><strong>Atributes</strong> are read-only variables that can only be accessed by the vertex shader.</li>
<li><strong>Varyings</strong> are variables that the vertex shader can write and pass to the fragment shader. Vertex shaders are always executed before fragment shaders.</li>
</ul>

<p>Here is the beginning of the vertex shader definition.</p>
<pre class="highlight javascript"><span class="nx">vertexShader</span><span class="err">:</span> <span class="p">[</span>
  <span class="s2">&quot;#define PHONG&quot;</span><span class="p">,</span>
  <span class="s2">&quot;varying vec3 vViewPosition;&quot;</span><span class="p">,</span>
  <span class="s2">&quot;varying vec3 vNormal;&quot;</span><span class="p">,</span>
</pre>
<p>https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib.js#L248</p>

<p>The vertex shader declares two varyings that it will pass to the fragment shader, the view position (camera perspective) and the normal.</p>

<p>The fragment shader&#39;s implementation is much more complex than the description I&#39;ve provided, it accounts for a number of different types of light source (other than the simple directional one we used). It also uses a slightly more advanced Blinn-Phong technique, but the basic principle is the same, using the angle between the surface normal and light source to calculate the color of the pixel.</p>
<pre class="highlight javascript"><span class="kr">float</span> <span class="nx">dotProduct</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span> <span class="nx">normal</span><span class="p">,</span> <span class="nx">lVector</span> <span class="p">);</span>
</pre>
<p>https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/lights<em>phong</em>fragment.glsl#L38</p>

<p>The <a title="The dot product - Wikipedia" href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> gives us the angle between the normal the light vector. If it is 10 or negative, the angle is a right angle or greater, the light is not facing the pixel and the diffuse term will be 0. If the dot product is positive, it tells us how bright the diffuse term should be. This isn&#39;t a physically accurate description of light, but it is a computationally cheap way to shade shiny surfaces, making it the basis for many other types of more complex shaders.</p>

        </div>
    </div>

        </div>
    </div>
</body>
</html>
